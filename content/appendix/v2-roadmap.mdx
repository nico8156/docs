---
title: "Améliorations envisagées (V2)"
---

# Améliorations envisagées (V2)

Un système n’est jamais terminé.  
Il évolue avec ses contraintes et ses usages.

---

## 1. Observabilité avancée

Mettre en place :

- Logs structurés
- Correlation IDs entre contexts
- Tracing distribué (OpenTelemetry)
- Métriques sur la latence outbox / projection
- Dashboard temps réel

Objectif : rendre le système pleinement observable en production.

---

## 2. Versioning explicite des événements

Introduire une stratégie formelle de versioning :

- version des domain events
- compatibilité backward
- gestion d’évolution de schéma
- migration progressive des projections

Objectif : faciliter l’évolution à long terme.

---

## 3. Orchestration et sagas explicites

Certaines interactions inter-contextes pourraient bénéficier :

- d’une couche d’orchestration dédiée
- de stratégies de compensation formalisées
- d’un modèle clair pour les transactions longues

Objectif : clarifier encore davantage les responsabilités.

---

## 4. Isolation multi-tenant

En cas d’évolution vers un modèle multi-tenant :

- isolation des projections
- partitionnement des événements
- séparation renforcée des données

Objectif : préparer l’architecture à l’échelle.

---

## 5. Renforcement infrastructure

- Pipeline CI/CD complet
- Build automatisé des containers
- Environnements éphémères pour les tests E2E
- Monitoring des files Kafka

Objectif : solidifier la dimension opérationnelle.

---
## 6. Style de code plus inspiré FP (pragmatique)

Sans chercher à “réécrire en FP”, l’objectif serait d’adopter progressivement des pratiques qui améliorent
la **robustesse** et la **testabilité** :

- **Séparation pur/impur** : isoler les effets (I/O, réseau, temps) derrière des ports, garder un cœur métier le plus pur possible
- **Écriture plus descriptive** : fonctions petites, composables, orientées transformation de données
- **Gestion d’erreurs explicite** : éviter les exceptions comme contrôle de flux, préférer des retours typés (`Result`/`Either`) et des erreurs métier structurées
- **Modélisation par types** : réduire les états invalides (value objects, états explicites, invariants)
- **Tests plus simples** : cœur métier testable sans mocks lourds, effets testés séparément en intégration/E2E

> Trade-off assumé : un peu plus de verbosité (types / wrappers), mais une baisse de complexité cognitive
> et une meilleure fiabilité en production.

---
## Conclusion

L’architecture actuelle est robuste et cohérente.

Les axes d’amélioration visent principalement :

- l’observabilité
- la gouvernance des événements
- l’évolutivité long terme
- la maturité opérationnelle
