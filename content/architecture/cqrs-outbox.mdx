---
title: "CQRS + Outbox"
---

---

# CQRS + Outbox â€” DÃ©cision architecturale centrale

## ğŸ¯ ProblÃ¨me

Dans un systÃ¨me distribuÃ©, publier un Ã©vÃ©nement immÃ©diatement aprÃ¨s un write pose un risque :

* crash entre write DB et publish Kafka
* double publication
* incohÃ©rence entre Ã©tat persistant et Ã©tat diffusÃ©
* difficultÃ© Ã  garantir la livraison

Dans un contexte mobile + temps rÃ©el, ce risque devient critique.

---

## ğŸ§  DÃ©cision

Mettre en place :

* CQRS strict (sÃ©paration write/read)
* Outbox persistÃ©e en base
* Dispatcher asynchrone vers Kafka
* Projection dÃ©diÃ©e pour le read model
* Push WebSocket aprÃ¨s projection

Le write ne publie jamais directement dâ€™Ã©vÃ©nement externe.

---

## ğŸ—ï¸ ImplÃ©mentation

### Write side

1. Command handler (ex: `Like.Set`)
2. Modification dâ€™agrÃ©gat
3. Persist de lâ€™agrÃ©gat
4. Persist dâ€™un event dans la table `outbox`
5. Commit transactionnel unique

La publication Kafka est dÃ©couplÃ©e du cycle HTTP.

---

### Dispatcher

Un process dÃ©diÃ© :

* lit la table outbox
* publie vers Kafka
* marque lâ€™Ã©vÃ©nement comme traitÃ©
* retry avec backoff si Ã©chec

---

### Projection

Un consumer Kafka :

* consomme lâ€™Ã©vÃ©nement
* met Ã  jour le read model
* pousse un Ã©vÃ©nement WebSocket
* inclut `{count, me, version, serverTime}`

---

## ğŸ”’ Garanties obtenues

* AtomicitÃ© write + event persistÃ©
* Idempotence via `commandId`
* Delivery at-least-once
* Reconstruction possible du read model
* Isolation du domaine mÃ©tier

---

## âš–ï¸ Trade-offs assumÃ©s

* ComplexitÃ© supÃ©rieure
* Eventual consistency
* Latence lÃ©gÃ¨rement accrue
* NÃ©cessitÃ© dâ€™observabilitÃ©

---

## ğŸ§© Pourquoi ne pas faire plus simple ?

Un CRUD classique :

* write
* publish
* update read

fonctionne en local, mais casse en production :

* crash mid-flight
* scaling horizontal
* dÃ©ploiement multi-instance
* rÃ©silience rÃ©seau

Le pattern CQRS + Outbox rend ces scÃ©narios maÃ®trisables.

---

## ğŸ“Š Vue simplifiÃ©e

```mermaid
sequenceDiagram
  participant API
  participant Write
  participant DB
  participant Outbox
  participant Kafka
  participant Projection
  participant WS

  API->>Write: Command
  Write->>DB: Persist aggregate
  Write->>Outbox: Persist event
  Outbox->>Kafka: Publish
  Kafka->>Projection: Consume
  Projection->>DB: Update read model
  Projection->>WS: Push update
```

---

## ğŸ RÃ©sultat

Un systÃ¨me :

* rÃ©silient
* scalable
* cohÃ©rent
* mobile-friendly
* prÃªt pour la production

---
